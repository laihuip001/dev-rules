# 🤖 Architect / Constructor モデル選定ガイド

> **目的**: Opus 4.5 (Architect) と Gemini 3 Pro (Constructor) の戦略的使い分け

---

## 1. 役割定義

| 役割 | モデル | 強み | コンテキスト |
|:---|:---|:---|:---|
| **🏛️ Architect** | Claude 4.5 Opus | 論理的推論、計画策定 | 200K tokens |
| **🔨 Constructor** | Gemini 3 Pro | 視覚的理解、大量コンテキスト | 2M tokens |

---

## 2. Architect (Opus) ユースケース

> **指針**: 「何を、なぜ作るか」を厳密に定義するフェーズ

| カテゴリ | ユースケース | 成果物 |
|:---|:---|:---|
| **📐 設計** | システムアーキテクチャ設計 | 設計書、ERD |
| | データスキーマ定義 | SQLスキーマ |
| | API仕様策定 | OpenAPI Spec |
| **📋 計画** | 実装計画書作成 | `implementation_plan.md` |
| | タスク分解・優先順位付け | タスクリスト |
| **🎯 意思決定** | 技術選定ディベート | 比較表 + 推奨案 |
| | トレードオフ分析 | ADR |
| **🔍 レビュー** | コードレビュー（論理チェック） | 指摘リスト |
| | 「悪魔の代弁者」レビュー | 反論リスト |
| **✍️ 文書** | 投資家向けメール、技術仕様書 | ドラフト |

---

## 3. Constructor (Gemini) ユースケース

> **指針**: 「どう作るか」を高速に実行するフェーズ

| カテゴリ | ユースケース | 成果物 |
|:---|:---|:---|
| **💻 実装** | フロントエンドUI実装 | React/Vue/HTML |
| | Vibe Coding (スクショ→コード) | Tailwind CSS |
| | 定型的なCRUD実装 | ボイラープレート |
| **🔎 調査** | 大規模リポジトリ検索 | 関連ファイルリスト |
| | レガシーコード理解 | 依存関係マップ |
| **🌐 Web** | 市場調査 (検索+閲覧) | サマリーレポート |
| | 競合プロダクト分析 | スクショ付き分析 |
| **🧪 検証** | ブラウザでの視覚的テスト | スクショ比較 |
| | UIバグの自動修正 | 修正コード |
| **📝 生成** | テストコード生成 | pytest/Jestファイル |

---

## 4. クイックリファレンス

| この状況では… | → 推奨モデル |
|:---|:---|
| 「何を作ればいいか分からない」 | **Architect** |
| 「設計図はある、コードを書きたい」 | **Constructor** |
| 「大量のファイルを読み込みたい」 | **Constructor** |
| 「この設計で本当にいいか不安」 | **Architect** |
| 「UIをスクショから再現したい」 | **Constructor** |
| 「曖昧なアイデアを整理したい」 | **Architect** |

---

## 5. ハイブリッドワークフロー

```
Phase 1: Architect (Opus)
├── 要件定義・計画策定
└── 論理的整合性の担保

Phase 2: Constructor (Gemini)
├── 実装・コーディング
└── 速度・コスト・コンテキストの活用

Phase 3: Critic (両者)
├── Opus: バグ特定
└── Gemini: 視覚的修正
```

---

## 6. 失敗パターンと対策

| モデル | 失敗パターン | 対策 |
|:---|:---|:---|
| **Opus** | コンテキスト溢れ | 大規模コードはGeminiで俯瞰 |
| **Gemini** | レイジーなコード (`// TODO`) | 論理設計はOpusに委譲 |

---

*Last Updated: 2026-01-08*
